let callbackFunc;

const responseTime = 200;

function toHexString(byteArray) {
  return Array.from(byteArray, function(byte) {
    return ('0' + (byte & 0xFF).toString(16)).slice(-2);
  }).join(' ')
}

const STD_BCH_XOR = 0x28;
const STD_BCH_MASK = 0x80;

const calcBCH = (msg) => {
  let bch = 0xf8;
  let i, j, bitA, bitB;

  for (i=0; i<3; i++)
  {
    let byte = msg[i];
    for (j=0; j<8; j++)
    {
      bitB = (STD_BCH_MASK & byte) ? 1 : 0;
      bitA = (STD_BCH_MASK & bch) ? 1 : 0;
      bch <<= 1;
      byte <<= 1;
      if (bitB != bitA) {
        bch = bch ^ STD_BCH_XOR;
      }
    }
  }

  return bch;
}

const startMockedTest = (cb) => {
  callbackFunc = cb;
}

const sendMockData = (msg) => {
  // console.log(` > --------------- ${toHexString(msg)}`);

  const remote = +msg[0];
  const code = +msg[1];
  const value = +msg[2];
  let data = {};

  if(code === 0xFF) { 
    if(value === 0x01) { //Recall
      if(remote === 0x06) {
        data = Buffer.from([0xFA, remote, 0x00, 0x00, calcBCH([remote, 0x00, 0x00]), remote, 0x01, 0x01, calcBCH([remote, 0x01, 0x01]), remote, 0x02, 0x00, calcBCH([remote, 0x02, 0x00]), remote, 0x03, 0x84, calcBCH([remote, 0x03, 0x84]), remote, 0x04, 0x42, calcBCH([remote, 0x04, 0x42]), remote, 0x05, 0x28, calcBCH([remote, 0x05, 0x28]), remote, 0x06, 0x84, calcBCH([remote, 0x06, 0x84]), remote, 0x07, 0x42, calcBCH([remote, 0x07, 0x42]), remote, 0x08, 0x28, calcBCH([remote, 0x08, 0x28]), remote, 0x09, 0x00, calcBCH([remote, 0x09, 0x00]), remote, 0x0a, 0x00, calcBCH([remote, 0x0a, 0x00]), remote, 0x0b, 0x00, calcBCH([remote, 0x0b, 0x00]), remote, 0x0c, 0x00, calcBCH([remote, 0x0c, 0x00]), remote, 0x0d, 0x08, calcBCH([remote, 0x0d, 0x08]), remote, 0x0e, 0x10, calcBCH([remote, 0x0e, 0x10]), remote, 0x0f, 0x88, calcBCH([remote, 0x0f, 0x88]), remote, 0x10, 0x00, calcBCH([remote, 0x10, 0x00]), remote, 0x11, 0x10, calcBCH([remote, 0x11, 0x10]), remote, 0x12, 0x88, calcBCH([remote, 0x12, 0x88]), remote, 0x13, 0x00, calcBCH([remote, 0x13, 0x00]),  remote, 0x15, 0x00, calcBCH([remote, 0x15, 0x00]), remote, 0x16, 0x60, calcBCH([remote, 0x16, 0x60]), remote, 0x17, 0xe2, calcBCH([remote, 0x17, 0xe2]), remote, 0x18, 0x01, calcBCH([remote, 0x18, 0x01]), remote, 0x19, 0xb0, calcBCH([remote, 0x19, 0xb0]), remote, 0x1a, 0x00, calcBCH([remote, 0x1a, 0x00]), remote, 0x1b, 0x00, calcBCH([remote, 0x1b, 0x00]), remote, 0x1c, 0x00, calcBCH([remote, 0x1c, 0x00]), remote, 0x1d, 0x00, calcBCH([remote, 0x1d, 0x00]), remote, 0x1e, 0x00, calcBCH([remote, 0x1e, 0x00]), remote, 0x1f, 0x00, calcBCH([remote, 0x1f, 0x00]), remote, 0x20, 0x00, calcBCH([remote, 0x20, 0x00]), remote, 0x21, 0x00, calcBCH([remote, 0x21, 0x00]), remote, 0x22, 0x18, calcBCH([remote, 0x22, 0x18]), remote, 0x23, 0x00, calcBCH([remote, 0x23, 0x00]), remote, 0x24, 0x00, calcBCH([remote, 0x24, 0x00]), remote, 0x25, 0x00, calcBCH([remote, 0x25, 0x00]), remote, 0x26, 0x00, calcBCH([remote, 0x26, 0x00]), remote, 0x27, 0x00, calcBCH([remote, 0x27, 0x00]), remote, 0x28, 0x00, calcBCH([remote, 0x28, 0x00]), remote, 0x2a, 0x00, calcBCH([remote, 0x2a, 0x00]), remote, 0x2b, 0x00, calcBCH([remote, 0x2b, 0x00]), remote, 0x2c, 0x04, calcBCH([remote, 0x2c, 0x04]), remote, 0x2d, 0x08, calcBCH([remote, 0x2d, 0x08]), remote, 0x2e, 0x00, calcBCH([remote, 0x2e, 0x00])], 'hex');
      }
      else if(remote !== 0x0A) {
        data = Buffer.from([remote, 0x00, 0x00, calcBCH([remote, 0x00, 0x00]), remote, 0x01, 0x01, calcBCH([remote, 0x01, 0x01]), remote, 0x02, 0x00, calcBCH([remote, 0x02, 0x00]), remote, 0x03, 0x84, calcBCH([remote, 0x03, 0x84]), remote, 0x04, 0x42, calcBCH([remote, 0x04, 0x42]), remote, 0x05, 0x28, calcBCH([remote, 0x05, 0x28]), remote, 0x06, 0x84, calcBCH([remote, 0x06, 0x84]), remote, 0x07, 0x42, calcBCH([remote, 0x07, 0x42]), remote, 0x08, 0x28, calcBCH([remote, 0x08, 0x28]), remote, 0x09, 0x00, calcBCH([remote, 0x09, 0x00]), remote, 0x0a, 0x00, calcBCH([remote, 0x0a, 0x00]), remote, 0x0b, 0x00, calcBCH([remote, 0x0b, 0x00]), remote, 0x0c, 0x00, calcBCH([remote, 0x0c, 0x00]), remote, 0x0d, 0x08, calcBCH([remote, 0x0d, 0x08]), remote, 0x0e, 0x10, calcBCH([remote, 0x0e, 0x10]), remote, 0x0f, 0x88, calcBCH([remote, 0x0f, 0x88]), remote, 0x10, 0x00, calcBCH([remote, 0x10, 0x00]), remote, 0x11, 0x10, calcBCH([remote, 0x11, 0x10]), remote, 0x12, 0x88, calcBCH([remote, 0x12, 0x88]), remote, 0x13, 0x00, calcBCH([remote, 0x13, 0x00]),  remote, 0x15, 0x00, calcBCH([remote, 0x15, 0x00]), remote, 0x16, 0x60, calcBCH([remote, 0x16, 0x60]), remote, 0x17, 0xe2, calcBCH([remote, 0x17, 0xe2]), remote, 0x18, 0x01, calcBCH([remote, 0x18, 0x01]), remote, 0x19, 0xb0, calcBCH([remote, 0x19, 0xb0]), remote, 0x1a, 0x00, calcBCH([remote, 0x1a, 0x00]), remote, 0x1b, 0x00, calcBCH([remote, 0x1b, 0x00]), remote, 0x1c, 0x00, calcBCH([remote, 0x1c, 0x00]), remote, 0x1d, 0x00, calcBCH([remote, 0x1d, 0x00]), remote, 0x1e, 0x00, calcBCH([remote, 0x1e, 0x00]), remote, 0x1f, 0x00, calcBCH([remote, 0x1f, 0x00]), remote, 0x20, 0x00, calcBCH([remote, 0x20, 0x00]), remote, 0x21, 0x00, calcBCH([remote, 0x21, 0x00]), remote, 0x22, 0x18, calcBCH([remote, 0x22, 0x18]), remote, 0x23, 0x00, calcBCH([remote, 0x23, 0x00]), remote, 0x24, 0x00, calcBCH([remote, 0x24, 0x00]), remote, 0x25, 0x00, calcBCH([remote, 0x25, 0x00]), remote, 0x26, 0x00, calcBCH([remote, 0x26, 0x00]), remote, 0x27, 0x00, calcBCH([remote, 0x27, 0x00]), remote, 0x28, 0x00, calcBCH([remote, 0x28, 0x00]), remote, 0x2a, 0x00, calcBCH([remote, 0x2a, 0x00]), remote, 0x2b, 0x00, calcBCH([remote, 0x2b, 0x00]), remote, 0x2c, 0x04, calcBCH([remote, 0x2c, 0x04]), remote, 0x2d, 0x08, calcBCH([remote, 0x2d, 0x08]), remote, 0x2e, 0x00, calcBCH([remote, 0x2e, 0x00])], 'hex');
      }
    }
    else if(value === 0x02) { //Poll
      if(remote === 0x07) {
        data = [0xFE, ...msg];
      }
      else if(remote === 0x08) {
        data = [remote, 0x04, 0x52, calcBCH([remote, 0x04, 0x52]), remote+1, 0x03, 0x32, calcBCH([remote+1, 0x03, 0x32]), remote, 0x05, 0x25, calcBCH([remote, 0x05, 0x25]), remote+1, 0x04, 0x12, calcBCH([remote+1, 0x04, 0x12]), remote, 0x07, 0x44, calcBCH([remote, 0x07, 0x44])];
      }
      else if(remote !== 0x0A) {
        data = msg;
      }
    }
    setTimeout(() => {
      // console.log(` --------------- < ${toHexString(data)}`);
      callbackFunc(data);
    }, responseTime);
  }
  else { //Command
    if(msg.length === 8) {
      // console.log(' --------------- Command received -----------------');
      data = Buffer.from([remote, 0xFF, 0x01, 0x00], 'hex');

      setTimeout(() => {
        // console.log(` --------------- < ${toHexString(data)}`);
        callbackFunc(data);
      }, responseTime);
    }
  }
}

module.exports = { startMockedTest, sendMockData }